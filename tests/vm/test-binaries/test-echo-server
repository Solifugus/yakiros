#!/usr/bin/env python3
"""
Hot-swap capable echo server for testing FD-passing upgrades.

This server:
1. Accepts TCP connections on specified port
2. Echoes received data back to clients
3. Supports hot-swap via FD-passing (HANDOFF_FD environment variable)
4. Maintains client connections during upgrades
"""

import os
import sys
import socket
import select
import signal
import time
import json
import threading
from datetime import datetime

class EchoServer:
    def __init__(self, port):
        self.port = port
        self.running = True
        self.connections = {}  # fd -> client info
        self.server_socket = None
        self.stats = {
            'start_time': datetime.now().isoformat(),
            'connections_total': 0,
            'messages_total': 0,
            'version': os.environ.get('SERVICE_VERSION', '1.0')
        }

        # Setup logging
        self.log_file = open('/var/log/test-echo-server.log', 'a')

    def log(self, message):
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_msg = f"[{timestamp}] [test-echo-server] {message}\n"
        self.log_file.write(log_msg)
        self.log_file.flush()
        print(log_msg.strip())

    def setup_socket(self):
        """Setup server socket, handling hot-swap if needed"""
        handoff_fd = os.environ.get('HANDOFF_FD')

        if handoff_fd:
            # We're receiving a hot-swap handoff
            self.log(f"Hot-swap handoff detected, using FD {handoff_fd}")
            self.server_socket = socket.fromfd(int(handoff_fd), socket.AF_INET, socket.SOCK_STREAM)
            self.stats['handoff_received'] = True
        else:
            # Normal startup
            self.log(f"Starting echo server on port {self.port}")
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind(('', self.port))
            self.server_socket.listen(10)
            self.stats['handoff_received'] = False

    def handle_handoff_request(self, signum, frame):
        """Handle SIGUSR1 - initiate handoff to new process"""
        self.log("Handoff request received via SIGUSR1")

        try:
            # Send our server socket FD to the new process
            # In a real implementation, this would use SCM_RIGHTS over a Unix socket
            # For this test, we'll simulate by writing the FD info
            handoff_info = {
                'server_fd': self.server_socket.fileno(),
                'port': self.port,
                'connections': len(self.connections),
                'stats': self.stats,
                'timestamp': datetime.now().isoformat()
            }

            with open('/run/test-echo-handoff.json', 'w') as f:
                json.dump(handoff_info, f)

            self.log(f"Handoff info written: {len(self.connections)} active connections")

            # In real FD-passing, we'd transfer the socket here
            # For testing purposes, we'll just indicate successful handoff
            time.sleep(1)  # Simulate handoff process
            self.log("Handoff complete, shutting down")
            self.running = False

        except Exception as e:
            self.log(f"Handoff failed: {e}")

    def create_readiness_file(self):
        """Create readiness file to signal YakirOS we're ready"""
        with open('/run/test-echo-ready', 'w') as f:
            f.write(f"Ready at {datetime.now().isoformat()}\n")
            f.write(f"Port: {self.port}\n")
            f.write(f"PID: {os.getpid()}\n")

    def run(self):
        """Main server loop"""
        signal.signal(signal.SIGUSR1, self.handle_handoff_request)

        try:
            self.setup_socket()
            self.create_readiness_file()
            self.log(f"Echo server ready on port {self.port} (PID {os.getpid()})")

            while self.running:
                # Use select to handle multiple connections
                readable = [self.server_socket] + list(self.connections.keys())

                try:
                    ready, _, _ = select.select(readable, [], [], 1.0)
                except select.error:
                    continue

                for sock in ready:
                    if sock == self.server_socket:
                        # New connection
                        try:
                            client, addr = self.server_socket.accept()
                            self.connections[client] = {
                                'addr': addr,
                                'connect_time': datetime.now().isoformat(),
                                'messages': 0
                            }
                            self.stats['connections_total'] += 1
                            self.log(f"New connection from {addr[0]}:{addr[1]}")
                        except socket.error as e:
                            self.log(f"Accept error: {e}")

                    else:
                        # Data from existing connection
                        try:
                            data = sock.recv(1024)
                            if data:
                                # Echo the data back
                                response = f"ECHO: {data.decode('utf-8', errors='replace')}"
                                sock.send(response.encode())
                                self.connections[sock]['messages'] += 1
                                self.stats['messages_total'] += 1
                            else:
                                # Client disconnected
                                addr = self.connections[sock]['addr']
                                self.log(f"Client {addr[0]}:{addr[1]} disconnected")
                                sock.close()
                                del self.connections[sock]
                        except socket.error:
                            # Connection error, remove client
                            if sock in self.connections:
                                addr = self.connections[sock]['addr']
                                self.log(f"Connection error with {addr[0]}:{addr[1]}")
                                sock.close()
                                del self.connections[sock]

        except Exception as e:
            self.log(f"Server error: {e}")

        finally:
            self.cleanup()

    def cleanup(self):
        """Clean shutdown"""
        self.log("Echo server shutting down")

        # Close all client connections
        for sock in list(self.connections.keys()):
            sock.close()

        # Close server socket
        if self.server_socket:
            self.server_socket.close()

        # Remove readiness file
        try:
            os.remove('/run/test-echo-ready')
        except:
            pass

        # Write final stats
        self.stats['shutdown_time'] = datetime.now().isoformat()
        with open('/run/test-echo-stats.json', 'w') as f:
            json.dump(self.stats, f, indent=2)

        self.log_file.close()

if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080

    server = EchoServer(port)
    try:
        server.run()
    except KeyboardInterrupt:
        server.log("Interrupted by user")
    except Exception as e:
        server.log(f"Fatal error: {e}")
        sys.exit(1)